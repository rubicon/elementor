// Inspired by "Dependency Extraction Webpack Plugin" by @wordpress team.
// Link: https://github.com/WordPress/gutenberg/tree/trunk/packages/dependency-extraction-webpack-plugin

const { sources: { RawSource } } = require( 'webpack' );

module.exports = class ExtractDependenciesWebpackPlugin {
	constructor( {
		apps,
		extensions,
		handlePrefix,
		i18n,
	} = {} ) {
		if ( ! handlePrefix ) {
			throw new Error( 'handlePrefix is required in Webpack.config' );
		}

		this.handlePrefix = handlePrefix;
		this.i18n = i18n;
		this.extensions = extensions || [];
		this.apps = apps || [];
	}

	apply( compiler ) {
		compiler.hooks.thisCompilation.tap( this.constructor.name, ( compilation ) => {
			let handlesAssetsMap;

			compilation.hooks.processAssets.tap( { name: this.constructor.name }, () => {
				handlesAssetsMap = [ ...compilation.entrypoints ].reduce( ( map, [ entryName, entrypoint ] ) => {
					const chunk = entrypoint.chunks.find( ( { name } ) => name === entryName );
					const chunkJSFile = this.getFileFromChunk( chunk );

					if ( ! chunkJSFile ) {
						return map;
					}

					const deps = this.getDepsFromChunk( compilation, chunk );

					const assetFilename = this.generateAssetsFileName(
						compilation.getPath( '[file]', { filename: chunkJSFile } )
					);

					const handle = this.generateHandleName( entryName );

					const content = this.createAssetsFileContent( {
						deps,
						entryName,
						i18n: this.i18n,
					} );

					// Add source and file into compilation for webpack to output.
					compilation.assets[ assetFilename ] = new RawSource( content );

					chunk.files.add( assetFilename );

					map[ handle ] = assetFilename;

					return map;
				}, {} );
			} );

			compilation.hooks.afterProcessAssets.tap( { name: this.constructor.name }, () => {
				const loaderFileContent = this.getLoaderFileContent( handlesAssetsMap );

				compilation.assets[ 'loader.php' ] = new RawSource( loaderFileContent );
			} );
		} );
	}

	getEntryType( entryName ) {
		if ( this.extensions.includes( entryName ) ) {
			return 'extension';
		}

		if ( this.apps.includes( entryName ) ) {
			return 'app';
		}

		return 'util';
	}

	getLoaderFileContent( entriesData ) {
		const entriesContent = Object.entries( entriesData ).map( ( [ handle, assetFileName ] ) => {
			return `
	$data['${ handle }'] = require __DIR__ . '/${ assetFileName }';`;
		} );

		return `<?php
if ( ! defined( 'ABSPATH' ) ) {
	exit;
}

/**
 * This file is generated by Webpack, do not edit it directly.
 */

add_filter( 'elementor/editor-v2/packages/config', function( $data ) {
${ entriesContent.join( '\n' ) }

	return $data;
} );
`;
	}

	getDepsFromChunk( compilation, chunk ) {
		const externals = Object.keys( compilation.options.externals );
		const depsSet = new Set();

		compilation.chunkGraph.getChunkModules( chunk ).forEach( ( module ) => {
			[ ...( module.modules || [] ), module ].forEach( ( subModule ) => {
				const isExternalDep = externals.includes( subModule.userRequest );

				if ( ! isExternalDep ) {
					return;
				}

				depsSet.add( subModule.userRequest );
			} );
		} );

		return depsSet;
	}

	createAssetsFileContent( { deps, i18n, entryName } ) {
		const handleName = this.generateHandleName( entryName );
		const type = this.getEntryType( entryName );

		const depsAsString = [ ...deps ]
			.map( ( dep ) => this.replaceDependencyNames( dep ) )
			.filter( ( dep ) => dep !== handleName )
			.sort()
			.map( ( dep ) => `'${ dep }',` )
			.join( '\n\t\t' );

		const i18nContent = i18n ? `[
		'domain' => '${ i18n.domain }',
		'replace_requested_file' => ${ ( i18n.replaceRequestedFile ?? true ).toString() },
	]` : '[]';

		const content =
`<?php
if ( ! defined( 'ABSPATH' ) ) {
	exit;
}

/**
 * This file is generated by Webpack, do not edit it directly.
 */

return [
	'handle' => '${ handleName }',
	'src' => plugins_url( '/', __FILE__ ) . '${ entryName }{{MIN_SUFFIX}}.js',
	'i18n' => ${ i18nContent },
	'type' => '${ type }',
	'deps' => [
		${ depsAsString }
	],
];
`;

		return content;
	}

	getFileFromChunk( chunk ) {
		return [ ...chunk.files ].find( ( f ) => /\.js$/i.test( f ) );
	}

	replaceDependencyNames( name ) {
		const map = new Map( [
			[ '@elementor/', 'elementor-packages-' ],
			[ '@wordpress/', 'wp-' ],
		] );

		for ( const [ key, value ] of map ) {
			if ( name.startsWith( key ) ) {
				return name.replace( key, value );
			}
		}

		return name;
	}

	generateAssetsFileName( filename ) {
		return filename.replace( /(\.min)?\.js$/i, '.asset.php' );
	}

	generateHandleName( name ) {
		return `${ this.handlePrefix }-${ name }`;
	}
};
